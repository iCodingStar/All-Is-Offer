## 操作系统知识复习

1、操作系统两个最基本特征

并发和共享

2、操作系统的主要功能

处理机管理、存储器管理、设备管理和文件管理

处理机管理：主要是对进程的管理：进程控制、进程同步、进程通信、调度。

存储器管理：内存分配、内存保护、地址映射、内存扩充

设备管理：缓冲管理、设备分配、设备处理

文件管理：文件存储空间的管理、目录管理、文件的读/写管理和保护

## 进程

1、进程的特征

结构特征：程序段+数据段+PCB组成，也称之为进程实体。

动态性：进程的本质就是进程实体的一次执行过程。由创建而产生，由调度而执行，由撤销而消亡。

并发性：重要特征

独立性：独立运行，独立分配资源，独立接受调度的基本单位

异步性：进程按各自独立的不可预知的速度向前推进，或者说进程实体按异步方式运行。

2、进程的基本状态

就绪 执行 阻塞

增加挂起状态，增加创建状态和终止状态。

3、进程控制块PCB的作用

PCB记录了操作系统所需的用于描述进程的当前情况以及控制进程运行的全部信息。PCB是进程存在的唯一标志。

PCB中的信息：

进程标识符、处理机状态、进程调度信息、进程控制信息

PCB的组织方式：链接方式、索引方式

4、进程控制

引起进程创建：1、用户登录 2、作业调度 3、提供服务 4、应用请求

进程创建过程：1、申请空白PCB 2、分配资源 3、初始化PCB 4、新进程插入就绪队列

引起进程终止：正常结束 异常结束（越界错误、非法指令、运行超时、IO故障等）

进程终止的过程：1、根据被终止进程的标识符，从PCB集合检索出该进程的PCB，读取进程状态

2、若进程处于执行，终止其执行并设调度状态为真。
3、若进程还有子孙进程，应先将所有子孙进程终止。
4、将被终止进程的全部资源归还给父进程或系统
5、将被终止进程从队列中移出

进程阻塞和唤醒：1、请求系统服务 2、启动某种操作 3、新数据尚未到达 4、无新工作可做

block原语，wakeup原语

进程的挂起和激活：suspend和active原语

## 进程同步

遵循的规则：

空闲让进、忙则等待、有限等待、让权等待

信号量机制：整型信号量、记录型信号量、AND型信号量、

管程：一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。

经典的进程同步问题：

生产者消费者问题：记录型信号量、AND型信号量（思想：将进程在整个运行过程中所需要的全部资源一次性分配给进程，待进程使用完后一起释放。如果请求的资源不能分配到进程，则一个也不分配）

哲学家进餐厅

读者-写者

## 进程间通信

信号量
管道:：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 
有名管道 (named pipe) ：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
共享内存 
消息队列
套接字( socket ) ：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

## 线程

1、与进程的比较

第一，调度。在引入线程的OS中将线程作为调度的基本单位，而进程作为资源拥有的基本单位，使线程轻装上阵，提高系统的并发程度。同一进程中，线程的切换不会引起进程的切换，当从一个进程的线程切换到另一个进程的线程，将会引起进程切换

第二，并发性。在引入线程的OS中，不仅进程可以并发，一个进程内的多个线程也可以并发执行，从而提高系统的利用率和吞吐量。

第三，拥有资源。进程是拥有资源的基本单位，线程不拥有资源（其实也有一点必不可少的资源），线程可以访问进程的代码段、数据段以及进程所拥有的系统资源，如打开的文件、IO设备等。这些资源为进程内的所有线程共享

第四，系统开销。创建或者撤销进程时，系统要为之分配和回收进程控制块，分配回收资源，如内存和IO设备等。线程的切换只需要保存和设置少量寄存器内容，系统开销远小于进程。

2、线程的属性

一、轻型实体 二、独立调度的基本单位 三、可以并发执行 四、共享进程资源

3、线程间通信

互斥锁 条件变量 信号量机制

4、线程的实现方式

内核支持线程、用户级线程、组合的方式


## 调度算法
1.先来先服务FCFS：有利于长作业

2.短作业优先

3、优先级法

两类：非抢占式和抢占式

优先权的类型：

静态优先权0-7 0-255 创建进程时确定，程序运行期间不再改变 

动态优先权：优先权可以随着进程的推进或随等待时间的增加而改变

具体算法：

高响应比优先调度算法

优先权 = （等待时间+要求服务时间）/要求服务时间

该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务

时间片轮转

多级反馈队列调度算法：无需指明进程或作业的执行时间

原理：设置多个就绪队列，并赋予不同的优先级。第一个队列的优先级最高，第二个次之，其余的逐个降低。在优先级最高的队列中，每个进程规定的时间片越小，第二个队列时间片比第一个长一倍，第i+1个比第i个长一倍。

过程：当一个新进程进入内存后，首先放入第一队列的队尾，当轮到该进程执行时，若在时间片内完成，便可撤离系统。否则，调度程序便将此进程转入第二队列的队尾，按同样的策略执行。需要注意的是，仅当第一队列空闲时，调度程序才调度第二队列中的进程运行。其他队列类似。如果当前处理机正在为第i个队列某进程所使用，又有新进程进入优先级更高的队列，则新进程将抢占处理机，调度程序把正在运行的进程放回到第i个队列的末尾。

## 死锁

原因：1、竞争资源 2、进程间推进顺序非法

死锁的必要条件：

1.互斥条件：一段时间内某资源只由一个进程占用
2.请求和保持条件：保持了至少一个资源又提出新的资源请求，新资源被其他进程占有，此时请求线程阻塞又对自己获得的其他资源保持不放。
3.不剥夺条件：指进程已获得的资源未使用完之前，不能被剥夺，只能使用完自己释放。
4.环路等待：存在一个进程-资源的环形链。

处理死锁的方法：

预防死锁、避免死锁、检测死锁、解除死锁

预防和避免都属于事先预防的策略。可以通过破坏死锁的必要条件去实现。

检测死锁和解除死锁的做法是将进程从死锁状态中解脱出来。常用的做法是撤销或挂起一些进程，以便回收一些资源然后分配给阻塞的进程，使之转为就绪，继续运行。

解除死锁：1、剥夺资源 2、撤销进程（直接的做法是全部死锁进程撤销，或按某个顺序去撤销）

预防的方法：

摒弃请求和保持：采用这种方法时，系统规定所有进程在运行前必须一次性申请其需要的全部资源。有，分配，摒弃了请求条件。不足，不分配。摒弃了保持条件。

摒弃不剥夺：已经保持了某些资源又提出新的资源请求而不能满足时，必须释放保持的资源。摒弃了不剥夺。

摒弃环路等待：系统将资源线性排队并赋予不同序号，规定进程对资源的请求必须严格按照资源序号提出。

## 系统安全状态

银行家算法：Max Allocation Need Available

判断请求<Need&&请求<Available，尝试分配并修改矩阵结构，然后执行安全性算法。若安全才正式分配。否则，恢复矩阵为原来的状态，让进程等待。

安全性算法


## 存储器管理

连续分配

分区分配算法：

```
1、首次适应：分配时从空闲分区链首顺序查找，直到找到一个大小能满足要求的空闲分区为止，从中划出请求大小的内存，如果不能，此次分配失败。
2、循环首次适应：首次适应基础上改变而来，每次不是从链首查找而是从上次找到的空闲分区的下一个空闲分区开始查找。
3、最佳适应：是指每次把既能满足要求又是最小的空闲分区给作业，缺点会留下难以利用的小空间。
4、最坏适应：挑选一个最大的空闲分区给作业，缺点使存储器缺乏大的存储空间。
5、快速适应：是指将空闲分区根据容量大小分类，对每一类具有相同容量的所有空闲分区，单独设置一张空闲分区链表，内存中在设立一张索引表。该算法的优点是查找效率高，不易产生内存碎片，但空闲分区划分的越细，浪费越严重，这是一种以空间换时间的做法。
```

连续分配会有很多碎片，虽然可以通过紧凑的方式拼接成大空间，但必须付出很大开销。

离散分配：分页存储管理和分段存储管理

## 分页存储管理

分页：页号＋页内地址

页面（一个进程的逻辑地址空间划分若干大小的片，简称页面） 
页表（页号 － 块号对）
地址变换机构：用于用户地址空间的逻辑地址到物理地址的转换。

基本地址变换机构 具有快表的地址变换机构

由于页表是存放在内存中的，CPU每次存取一个数据时，都要访问两次内存。第一次访问内存的页表，得到块号，再将块号与页内偏移量
拼接得到物理地址。第二次访问内存时才可以获得所需数据。提高地址变换速度。无需经过页表（第一次需要）

两级页表和多级页表

## 分段存储管理

满足用户和程序员的一系列需要。

1，方便编程 2，信息共享 3，信息保护 4，动态增长 5，动态连接

分段地址：段号 ＋ 段内地址

段表：进程查找段表找到每个段对应的内存区

地址变换机构：逻辑地址到物理地址的变换

## 分页和分段的区别

1，页是信息的物理单位，分页是为了实现离散分配方式，以减少内存零头，提高内存利用率，是满足系统管理的需要而不是用户。段是信息的逻辑单位，它含有一组意义相对完整的信息。分段是更好的满足用户需要。

2，页的大小固定且由系统决定。512B － 8KB。段的长度不确定。

3，分页的地址空间是一维的，段的地址空间是二维的，程序员在标识一个地址时既需要段号又需给出段内地址。

## 局部性原理

时间局部性：某条指令 空间局部性：附近的存储单元

虚拟存储器：请求调页＋页面置换

何处调页：文件区，对换区，页面共享（其他进程）

## 页面置换算法

最佳置换：

淘汰以后永不使用或最长未来时间内不使用的页面。

先进先出置换：

淘汰最先进入内存的页面

LRU置换算法：

最近最久未使用的页面。需要寄存器和栈的支持。

Clock算法：页面使用循环队列链接，页面被访问时将访问位置1，当需要换出时，检查访问位，是0换出，如果是1置为0，继续滞留内存一次。按FIFO检查下一个页面。检查到最后一个还是1时，回到头，检查第一个。

改进的Clock算法。

## 磁盘调度

磁盘调度的目标是使磁盘的平均寻道时间最短。

FCFS，先来先服务算法

SSTF，最短寻道时间优先 要求访问的磁道离当前磁头最近。

SCAN扫描算法：欲访问的磁道离当前磁道最近，同时考虑方向。要求访问的磁道离当前磁头最近，且在磁道之外，直到没有更外的磁道才向里移动。又称电梯算法。

CSCAN：循环扫描。当前进程请求某一磁道，进程等待。CSCAN规定磁头只能单向移动。到达最外磁道后，立即返回最内磁道。即将最小磁道紧接最大磁道构成循环。

## LinuxIO模型

1、阻塞IO模型
以socket为例，在进程空间调用recvfrom，其系统调用知道数据包到达且被复制到应用进程的缓冲区或者发生错误才返回，在此期间一直等待，进程从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此称为阻塞IO


2、非阻塞IO模型
应用进程调用recvfrom，如果缓冲区没有数据直接返回EWOULDBLOCK错误。一般对非阻塞IO进行轮询，以确定是否有数据到来。

3、IO多路复用模型

Linux提供select/poll，通过将一个或多个fd传递给select或poll系统调用，阻塞在select上。select/poll顺序扫描fd是否就绪。

4、信号驱动IO

开启套接字接口信号驱动IO功能，并通过系统调用sigaction执行信号处理函数。当数据准备就绪时，为该进程生成SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主函数处理数据。

5、异步IO

告知内核启动某个操作，并让内核在整个操作完成后通知我们。它与信号驱动IO的区别在于信号驱动IO由内核通知我们何时可以开始IO操作。而异步IO模型由内核通知我们IO操作已经完成。

**IO多路复用**

当服务器需要处理多个客户端接入请求时，可以利用多线程或者IO多路复用处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，是的系统可以在单线程的情况下同时处理多个客户端的请求。与多线程相比，IO多路复用的优势在于开销小，节省了系统资源。