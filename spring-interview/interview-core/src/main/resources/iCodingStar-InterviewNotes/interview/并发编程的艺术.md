# 并发编程的艺术

## 并发编程的挑战

### 上下文切换
- CPU通过时间片算法循环执行任务，任务之间切换需要保存上一个任务状态，这就是上下文切换。

#### 多线程一定快吗？
- 由于上下文切换，因而多线程不一定比单线程效率高。

#### 测试上下文切换次数和时长
- 切换时长测试：Lmbench3
- 切换次数测试：vmstat(每秒1000多次)

#### 如何减少上下文切换
- 无锁并发编程：多线程竞争锁会引起上下文切换,在多线程处理数据时，可以将数据的ID通过取模Hash分组，不同的线程处理不同分组的数据。
- CAS算法：使用CAS算法更新数据，不需要加锁。
- 使用最小线程：避免创建过多的线程，根据数据量的大小调整。
- 协程：单线程里面实现多任务的调度，在单线程中维护多个任务的切换。

#### 减少上下文切换实战
* 通过减少大量的waiting线程来减少上下文切换次数。
  * jsatck命令dump线程信息 ： `jstack 4883 > /home/star/logs/java/dump.log`
  * 统计Java进程中线程的状态 ： `grep java.lang.Thread.State logs/java/dump.log|awk -F ":" '{print $2$3}'|sort|uniq -c`

### 死锁
#### 死锁实例
* 产生原因：多线程间互相等待对方释放资源完成自己的任务；
* jstack命令分析： `jstack pid`

```
Found one Java-level deadlock:
=============================
"t2":
  waiting to lock monitor 0x00007f7358003828 (object 0x0000000781ed9da0, a java.lang.String),
  which is held by "t1"
"t1":
  waiting to lock monitor 0x00007f73580060b8 (object 0x0000000781ed9dd0, a java.lang.String),
  which is held by "t2"

Java stack information for the threads listed above:
===================================================
"t2":
	at cn.codingstar.offer.lock.dead.DeadLockTest$DeadLockTaskB.run(DeadLockTest.java:69)
	- waiting to lock <0x0000000781ed9da0> (a java.lang.String)
	- locked <0x0000000781ed9dd0> (a java.lang.String)
	at java.lang.Thread.run(Thread.java:748)
"t1":
	at cn.codingstar.offer.lock.dead.DeadLockTest$DeadLockTaskA.run(DeadLockTest.java:44)
	- waiting to lock <0x0000000781ed9dd0> (a java.lang.String)
	- locked <0x0000000781ed9da0> (a java.lang.String)
	at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```
通过dump结果很容易发现产生了死锁。

#### 如何避免死锁
* 避免一个线程同时持有多把锁
* 避免一个线程在锁内同时占有多个资源，尽量保证一个锁只占用一个资源？
* 尝试使用定时锁，lock.tryLock(timeout)来代替使用内部锁机制；
* 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁失败的情况；

### 资源限制的挑战
* 分布式处理
* 资源复用，如数据库连接池

## Java并发机制底层实现原理

Java程序执行流程：Java代码---字节码---类加载器（JVM）---执行字节码

### volatile应用
volatile是轻量级的synchronized,在多处理器开发中保证了共享变量的可见性。
* 可见性：线程修改volatile共享变量时，另外一个线程可以读取到这个被修改的值。
* 优点：
  * 不会引起线程上下文的切换，执行成本比synchronized低；

#### 定义与原理
* 定义：Java编程语言允许线程访问线程共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁获取这个变量。
* CPU术语与说明
  * 内存屏障(memory barrier):是一组处理器指令，用于实现对内存操作的顺序限制
  * 缓冲行(cache lien):缓存中可以分配的最小存储单位。处理器填写缓存行时会加载生个缓存线，需要多个主内存周期
  * 原子操作(atomic operations)：不可中断的一条或一系列操作
  * 缓存行填充(cache line fill)：处理器识别到从内存中读取的操作数是可缓存的，处理器去读整个缓存行到适当的缓存（L1、L2、L3）
  * 缓存命中(cache hit)：如果进行高速缓存填充操作的位置，仍然是下次处理器访问的地址，处理器从缓存中读取操作数，而不是从内存中读取
  * 写命中(write hit):当处理器从操作数写回到一个内存缓存区域时，它会首先检查这个内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，这个操作被称为写命中
  * 写缺失(write miss the cache):一个有效的缓存行被写入到不存在的内存区域？
  
* volatile变量对应的汇编代码会添加一些lock开头的指令( `0x01a3de24: lock addl $0x0,(%esp)` )
  * 将当前处理器缓存的数据写回到系统内存
  * 写回内存的操作会使得其他cpu里缓存了该内存地址的数据无效
* 缓存一致性协议

每个处理器通过嗅探在总线上传播的数据来检测自己的缓存是否过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存。
  
* volatile两条实现原则
  * Lock前缀的指令会引起处理器缓存写回到内存；
  * 一个处理器缓存写回到内存会导致其他处理器的缓存无效；
  
#### volatile使用优化
* 缓存行填充
  * 在酷睿i7、酷睿、Atom和NetBurst等处理器上可以将volatile变量填充至64字节；

* 不适用填充：
  * 缓存行非64字节宽的处理器
  * 共享变量不会被频繁的写
  * JDk7下可能不生效，会淘汰重新排列无用字段

### synchronized实现原理与优化

在jdk1.6之前，synchronized是重量级锁，jdk1.6之后，对synchronized进行了优化.为了减少锁获得与释放带来的性能消耗,引入偏向锁和轻量级锁.

* 锁的形式
  * 对于普通同步方法,锁是当前实例对象
  * 对于静态同步方法,锁是当前类的Class对象
  * 对于同步方法块,锁是synchronized括号里面配置的对象

* 实现原理
  * JVM基于进入和退出Monitor对象来实现方法同步和代码块同步,但两者实现细节不一样
    * 代码块同步使用monitorenter和monitorexit实现
    * 方法的同步使用另一种方式实现,JVM并未说明,但是也可使用这种方法实现
    * monitorenter插入到同步代码块开始的位置
    * monitorexit插入到同步代码块结束的位置或者异常发生的位置
    * 任何一个对象都有一个monitor与之关联,线程执行到monitorenter指令时,试图获取对象所对应的monitor所有权,即对象锁
#### 对象头
synchronized锁存储在Java对象头里面.

#### 锁的升级与对比

Java SE 1.6为了减少获得锁和释放锁带来的性能开销,引入偏向锁和轻量级锁,在JavaSE1.6中,锁有4种状态:无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。随着竞争情况逐渐升级。锁可以升级，但是不能降级，目的是提高锁的获得与释放的效率。

##### 偏向锁
* 背景：在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程获得。为了使线程获得锁的代价更低，引入偏向锁。当一个线程访问同步代码块时会在对象头和栈帧的锁记录里存储偏向锁的ID，以后线程进入和退出同步代码块时，不需要进行CAS操作来加锁和解锁，只需要简单的测试一下对象头MarkWord里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要测试一下MarkWord中的偏向锁的标识是否设置成（表示当前是偏向锁）：如果没有设置，则需要使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
* 偏向锁的撤销
   * 偏向锁使用了一种等到竞争才释放锁的机制，当其他的线程试图竞争偏向锁时，持有偏向锁的线程才会释放偏向锁。
   * 偏向锁的撤销，要等到全局安全点。
       * 首先暂停拥有偏向锁的线程
       * 检查持有偏向锁的线程是否还存活
       * 如果持有偏向锁的线程不处于活动状态，将对象头设置为无锁状态；
       * 如果线程依然存活，拥有偏向锁的栈会被执行
       * 恢复到无锁或者标记对象不适合作为偏向锁
       * 唤醒暂停的线程
* 关闭偏向锁
  * java6与java7会延迟启动，通过`-XX:BiasedLockingStartingupDelay=0`关闭延迟启动
  * 关闭偏向锁：`-XX:UseBiasedLocking=false`

##### 轻量级锁

  * 轻量级加锁
  	 * 线程执行同步代码块之前，JVM会在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的Mark。/。Word复制到锁记录中，官方称为Displayed MarkWord。然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，表示当前线程获得锁，如果失败，表示其他线程获得锁，当前线程通过自旋来获得锁。
  * 轻量级解锁
    * 使用原子的CAS操作将Displayed MarkWord替换回对象头，如果成功，则表示没有竟态发生。如果失败，表示当前锁存在竞争，锁会膨胀成重量级锁。

### 原子操作的实现原理 


