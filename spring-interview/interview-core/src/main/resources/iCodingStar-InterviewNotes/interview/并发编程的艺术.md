# 并发编程的艺术

## 并发编程的挑战

### 上下文切换
- CPU通过时间片算法循环执行任务，任务之间切换需要保存上一个任务状态，这就是上下文切换。

#### 多线程一定快吗？
- 由于上下文切换，因而多线程不一定比单线程效率高。

#### 测试上下文切换次数和时长
- 切换时长测试：Lmbench3
- 切换次数测试：vmstat(每秒1000多次)

#### 如何减少上下文切换
- 无锁并发编程：多线程竞争锁会引起上下文切换,在多线程处理数据时，可以将数据的ID通过取模Hash分组，不同的线程处理不同分组的数据。
- CAS算法：使用CAS算法更新数据，不需要加锁。
- 使用最小线程：避免创建过多的线程，根据数据量的大小调整。
- 协程：单线程里面实现多任务的调度，在单线程中维护多个任务的切换。

#### 减少上下文切换实战
* 通过减少大量的waiting线程来减少上下文切换次数。
  * jsatck命令dump线程信息 ： `jstack 4883 > /home/star/logs/java/dump.log`
  * 统计Java进程中线程的状态 ： `grep java.lang.Thread.State logs/java/dump.log|awk -F ":" '{print $2$3}'|sort|uniq -c`

### 死锁
#### 死锁实例
* 产生原因：多线程间互相等待对方释放资源完成自己的任务；
* jstack命令分析： `jstack pid`
```
Found one Java-level deadlock:
=============================
"t2":
  waiting to lock monitor 0x00007f7358003828 (object 0x0000000781ed9da0, a java.lang.String),
  which is held by "t1"
"t1":
  waiting to lock monitor 0x00007f73580060b8 (object 0x0000000781ed9dd0, a java.lang.String),
  which is held by "t2"

Java stack information for the threads listed above:
===================================================
"t2":
	at cn.codingstar.offer.lock.dead.DeadLockTest$DeadLockTaskB.run(DeadLockTest.java:69)
	- waiting to lock <0x0000000781ed9da0> (a java.lang.String)
	- locked <0x0000000781ed9dd0> (a java.lang.String)
	at java.lang.Thread.run(Thread.java:748)
"t1":
	at cn.codingstar.offer.lock.dead.DeadLockTest$DeadLockTaskA.run(DeadLockTest.java:44)
	- waiting to lock <0x0000000781ed9dd0> (a java.lang.String)
	- locked <0x0000000781ed9da0> (a java.lang.String)
	at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```
通过dump结果很容易发现产生了死锁。

#### 如何避免死锁
* 避免一个线程同时持有多把锁
* 避免一个线程在锁内同时占有多个资源，尽量保证一个锁只占用一个资源？
* 尝试使用定时锁，lock.tryLock(timeout)来代替使用内部锁机制；
* 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁失败的情况；

### 资源限制的挑战
* 分布式处理
* 资源复用，如数据库连接池

