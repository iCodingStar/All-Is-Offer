# Java虚拟机

## 垃圾收集器与内存分配策略

### 对象已死吗？
Java堆在进行垃圾回收前如果确定对象的存活？
#### 引用计数法
* 定义：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用时效时，计数器就减1；任何时候计数器为0的对象就是不会再使用的对象。
* 优点：实现简单，判定效率高
* 缺点：无法解决循环引用的问题
* 应用：微软公司COM技术，使用ActionScript3的FlashPlayer，Python语言和在游戏领域广泛使用的Squirrel
* 然而Java虚拟机未采用
#### 可达性分析法
* 定义：通过一系列被称为GC Roots的对象作为起始点，从这些结点开始向下搜索，搜索所走过的路径被称为引用链。当一个对象从GC Roots到这个对象不可达时，则证明此对象不可用。
* GC Roots的选取
  * 虚拟机栈中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 本地方法栈JNI中引用的对象
#### 再谈引用
* 要点：无论是引用计数法还是可达性分析法，判断对象是否存活都与引用有关。
* 引用传统定义（jdk1.2前）：如果Reference类型数据中存储的数值代表另一块内存的起始地址，就称这块内存代表一个引用。
* 问题：那么，如何定义一些当内存够用时则能保留在内存中；在垃圾回收后，内存还是很紧张时，就将其回收的一些对象呢？很多系统的缓存设计都有这样的需求。
* 引用扩充定义（jdk1.2之后）：将引用分为强引用、软引用、弱引用、虚引用
   * 强引用（Strong Reference）：如`Object o = new Object();`,只要引用存在，就不会被垃圾收集器回收。
   * 软引用（Soft Reference）：用来描述一些还有用，但并非必需的对象。在系统将要发生内存异常之前，将会把这些对象列入回收范围，进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
   * 弱引用（Weak Reference）：也是用来描述一些非必需的对象，但是强度比软引用更弱一些，被弱引用引用的对象只生存到下一次垃圾回收之前。
   * 虚引用（Phantom Reference）：幽灵引用或者幻灵引用，是最弱的一种引用关系。虚引用的存在不会对对象的生存时间构成影响，也无法根据虚引用获得对象。设置虚引用的唯一目的就是在这个对象被回收的时候收到一条系统通知。

#### 生存还是死亡
定义：宣告一个对象死亡，至少需要经历两次标记过程。
  * 可达性分析时发现该对象没有与GC Roots相连的引用链的时候，进行第一次标记
  * 此时进行一次筛选，筛选的条件是该对象有无必要执行finalize方法
    * 当独享没有覆盖finalize方法
    * 或者finalize方法已经被虚拟机调用过
  * 没有必要执行finalize方法
  * 如果这个对象判定为有必要执行finalize方法，它将被放置在一个成为F_Queue的队列之中，稍后由虚拟机自建的，低优先级的Fializer线程去执行它，但是Finzlizer线程并不会承诺等待其结束。
  * 稍后虚拟机将对F_Queue中的对象进行第二次标记，如果此时引用成功的重新与任何一个对象相关联，那么它将被移出即将回收的集合，如果此时，对象还没有逃脱，那么基本上它就真的被回收了。
#### 回收方法区
* 特点
  * 方法区进行垃圾回收侠效率很低，虚拟机规范也不要求回收方法区
  * 在对中回收效率一般比较高（70% -- 95%）
* 回收内容
  * 废弃常量
    * 当前系统中没有一个String类型的引用指向这个常量对象
    * 当前系统中也没有一个字面量是这个常量值
  * 无用的类
    * 该类的所有实例已经被回收
    * 加载该类的ClassLoader已经被回收
    * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射创建类的实例
  * 查看类的装在与卸载的手段
    * -verbose:class
    * -XX:+TraceClassLoading
    * -XX:+TraceClassUnloading
* 应用
    * 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类的装卸载功能，以保证永久代不会溢出。

### 垃圾收集算法

#### 标记清除算法
* 定义
  * 标记出需要回收的对象
  * 清除已经标记的对象
* 问题
  * 效率问题：标记和清除两个过程效率都不高
  * 空间碎片：标记清除之后会产生大量的空间碎片，空间碎片过多，会导致在以后的程序运行过程中需要分配大对象时，因找不到连续可用的空间，而不得不提前触发另一次垃圾收集动作。

#### 复制算法
* 定义
  * 将内存划分为大小相等的两块，每次垃圾收集之后将存活的对象复制到另一块空间
* 优点
  * 实现简单，运行高效
* 缺点
  * 将内存缩小为原来的一半，代价过高
* 优化
  * 将内存按照8:1的比例划分为Eden区和Survivor区
  * 每次使用Eden区和其中的一块Survivor区
  * 回收时将Eden区和Survivor区还存活的对象一次性复制到另一块Survivor区
  * 清理掉刚才使用的Eden区和Survivor区
* 问题
  * 如果10%空间的survivor区无法容纳所有的存活对象怎么办？
  * 空间担保：
    * 无法容纳的对象通过空间担保机制直接进入老年代
    * 老年代就谁来担保？---标记整理吧
* 应用
  * 年轻代的垃圾收集
   
#### 标记整理算法
* 定义
  * 标记：标记出需要回收的对象
  * 整理：让存活的对象像一端移动，然后清理掉端外部的内存
* 应用：老年代的垃圾收集
#### 分代收集算法
* 定义：
  * 将内存划分为新生代和老年代
  * 新生代使用复制算法
  * 老年代使用标记整理算法

### HotSpot 垃圾收集算法实现

#### 枚举根节点

#### 安全点

#### 安全区域

### 垃圾收集器

#### Serial收集器

#### Par New收集器

#### Parallel Scavenge收集器

#### Serial Old收集器

#### Par Old收集器

#### CMS收集器

#### G1收集器