# Java虚拟机

## 垃圾收集器与内存分配策略

### 对象已死吗？
Java堆在进行垃圾回收前如果确定对象的存活？
#### 引用计数法
* 定义：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用时效时，计数器就减1；任何时候计数器为0的对象就是不会再使用的对象。
* 优点：实现简单，判定效率高
* 缺点：无法解决循环引用的问题
* 应用：微软公司COM技术，使用ActionScript3的FlashPlayer，Python语言和在游戏领域广泛使用的Squirrel
* 然而Java虚拟机未采用
#### 可达性分析法
* 定义：通过一系列被称为GC Roots的对象作为起始点，从这些结点开始向下搜索，搜索所走过的路径被称为引用链。当一个对象从GC Roots到这个对象不可达时，则证明此对象不可用。
* GC Roots的选取
  * 虚拟机栈中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 本地方法栈JNI中引用的对象
#### 再谈引用
* 要点：无论是引用计数法还是可达性分析法，判断对象是否存活都与引用有关。
* 引用传统定义（jdk1.2前）：如果Reference类型数据中存储的数值代表另一块内存的起始地址，就称这块内存代表一个引用。
* 问题：那么，如何定义一些当内存够用时则能保留在内存中；在垃圾回收后，内存还是很紧张时，就将其回收的一些对象呢？很多系统的缓存设计都有这样的需求。
* 引用扩充定义（jdk1.2之后）：将引用分为强引用、软引用、弱引用、虚引用
   * 强引用（Strong Reference）：如`Object o = new Object();`,只要引用存在，就不会被垃圾收集器回收。
   * 软引用（Soft Reference）：用来描述一些还有用，但并非必需的对象。在系统将要发生内存异常之前，将会把这些对象列入回收范围，进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
   * 弱引用（Weak Reference）：也是用来描述一些非必需的对象，但是强度比软引用更弱一些，被弱引用引用的对象只生存到下一次垃圾回收之前。
   * 虚引用（Phantom Reference）：幽灵引用或者幻灵引用，是最弱的一种引用关系。虚引用的存在不会对对象的生存时间构成影响，也无法根据虚引用获得对象。设置虚引用的唯一目的就是在这个对象被回收的时候收到一条系统通知。

#### 生存还是死亡
定义：宣告一个对象死亡，至少需要经历两次标记过程。
  * 可达性分析时发现该对象没有与GC Roots相连的引用链的时候，进行第一次标记
  * 此时进行一次筛选，筛选的条件是该对象有无必要执行finalize方法
    * 当独享没有覆盖finalize方法
    * 或者finalize方法已经被虚拟机调用过
  * 没有必要执行finalize方法
  * 如果这个对象判定为有必要执行finalize方法，它将被放置在一个成为F_Queue的队列之中，稍后由虚拟机自建的，低优先级的Fializer线程去执行它，但是Finzlizer线程并不会承诺等待其结束。
  * 稍后虚拟机将对F_Queue中的对象进行第二次标记，如果此时引用成功的重新与任何一个对象相关联，那么它将被移出即将回收的集合，如果此时，对象还没有逃脱，那么基本上它就真的被回收了。
#### 回收方法区
* 特点
  * 方法区进行垃圾回收侠效率很低，虚拟机规范也不要求回收方法区
  * 在对中回收效率一般比较高（70% -- 95%）
* 回收内容
  * 废弃常量
    * 当前系统中没有一个String类型的引用指向这个常量对象
    * 当前系统中也没有一个字面量是这个常量值
  * 无用的类
    * 该类的所有实例已经被回收
    * 加载该类的ClassLoader已经被回收
    * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射创建类的实例
  * 查看类的装在与卸载的手段
    * -verbose:class
    * -XX:+TraceClassLoading
    * -XX:+TraceClassUnloading
* 应用
    * 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类的装卸载功能，以保证永久代不会溢出。

### 垃圾收集算法

#### 标记清除算法
* 定义
  * 标记出需要回收的对象
  * 清除已经标记的对象
* 问题
  * 效率问题：标记和清除两个过程效率都不高
  * 空间碎片：标记清除之后会产生大量的空间碎片，空间碎片过多，会导致在以后的程序运行过程中需要分配大对象时，因找不到连续可用的空间，而不得不提前触发另一次垃圾收集动作。

#### 复制算法
* 定义
  * 将内存划分为大小相等的两块，每次垃圾收集之后将存活的对象复制到另一块空间
* 优点
  * 实现简单，运行高效
* 缺点
  * 将内存缩小为原来的一半，代价过高
* 优化
  * 将内存按照8:1的比例划分为Eden区和Survivor区
  * 每次使用Eden区和其中的一块Survivor区
  * 回收时将Eden区和Survivor区还存活的对象一次性复制到另一块Survivor区
  * 清理掉刚才使用的Eden区和Survivor区
* 问题
  * 如果10%空间的survivor区无法容纳所有的存活对象怎么办？
  * 空间担保：
    * 无法容纳的对象通过空间担保机制直接进入老年代
    * 老年代就谁来担保？---标记整理吧
* 应用
  * 年轻代的垃圾收集
   
#### 标记整理算法
* 定义
  * 标记：标记出需要回收的对象
  * 整理：让存活的对象像一端移动，然后清理掉端外部的内存
* 应用：老年代的垃圾收集
#### 分代收集算法
* 定义：
  * 将内存划分为新生代和老年代
  * 新生代使用复制算法
  * 老年代使用标记整理算法

### HotSpot 垃圾收集算法实现

#### 枚举根节点
* GC Roots
  * 全局性引用（方法区中常量引用、方法区中类的静态引用）
  * 执行上下文（虚拟机方法栈、本地方法栈）
* 问题
  * 逐个检查这里面的引用会耗费很多时间
  * 为了确保一致性，需要停顿所有的用户线程（Stop the world）
* 解决办法
  * 准确式GC：虚拟机有办法知道从知道哪些地方存这对象引用--OopMap(HotSpot虚拟机)
  
#### 安全点
* 背景
  * 在OopMap的协助下，可以很快完成GC Roots的枚举
  * 但是可能导致引用关系的变化，如果为每条指令都生成一个OopMap将会占用大量的内存
  * 所以只是在特定的位置将对象引用信息记录下来，即安全点
* 安全点选取
  * 标准：是否具有让程序长时间执行的特征
    * 指令复用
    * 方法调用
    * 循环跳转
    * 异常跳转等
* 问题
   * 如何让所有线程都处于安全点上
     * 抢先式中断
       * GC发生时，让所有线程中断，如果发现有线程不在安全点上，恢复线程，让它跑至安全点
     * 主动式中断
       * GC需要中断的时候，不直接对线程操作，仅仅简单的设置一个标置，各个线程执行时主动去轮训这个标置，发现标置位为真时，就自己中断挂起。
* 应用
  * 现在基本都使用抢先式中断来

#### 安全区域
* 背景
  * 线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，走到安全的地方中断挂起，这时需要安全区域来解决。
* 安全区域
  * 一段代码片段中，引用关系不会发生变化，着这个区域的任何地方GC都是安全的。
  * 在线程执行到安全区域的代码时，首先标识自己进入了Safe Region,那样，当在这段时间里JVM要发起GC时，就不用管自己标识为安全区域的线程了，当线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举，或者整个GC过程。如果完成了，线程就继续运行，如果没有完成，线程就必须等待直到收到可以离开安全区域为止。

### 垃圾收集器

#### Serial收集器
* 特点
  * 单线程垃圾收集器
  * 进行垃圾回收时，必须暂停掉所有的工作线程，直到=收集结束（Stop the world）。
* 清理算法
  * 年轻代：复制算法
  * 老年代：标记整理算法
* 优点
  * 简单而高效
  * 对于单个CPU来说，串行收集器没有线程交互的开销
  * 停顿时间可以控制在几十毫秒到100毫秒之内
* 应用
  * 虚拟机Client模式下默认的选择

#### Par New收集器
* 特点
  * 并行收集器是串行收集器的多线程版本，除了使用多个线程进行垃圾回收外，其余行为包括Serial收集器可用的所有控制参数
  * 收集算法，Stop the World、对象分配规则、回收策略都与Serial收集器完全一样
  * CPU数量越多，GC时对系统资源的利用越好
T =
* 应用
  * 虚拟机Server模式下新生代首选收集器
  * 除Serial收集器外，目前只有它与能与CMS收集器配合使用

#### Parallel Scavenge收集器
* 特点
  * 使用复制算法
  * 新生代垃圾收集器
  * 自适应调节策略
* 关注点
  * 控制应用程序的吞吐量在可控的范围内
  * 吞吐量：R = CPU用于运行用户代码的事件 / (CPU用于运行用户代码的事件 + CPU用于垃圾回收的事件)
* 应用
  * 适合在后台计算，而不需要太多交互的的任务
  
#### Serial Old收集器
* 特点
  * 单线程垃圾收集器

* 应用
  * 虚拟机Client模式下使用
  * 可以与Paraller Scavenge 配合使用
  * CMS收集器的后背预案

#### Paraller Old收集器
* 特点
  * 是Paraller scavenge老年代版本
  * 多线程
  * 标记整理算法
  * t吞吐量优先的垃圾收集算法完整呈现
* 应用
  * 吞吐量有限
  * 资源敏感的环境下适合使用

#### CMS收集器（Concurrent Mark Sweep）

* 目标
  * 获得最短停顿时间
* 步骤
  * 初始标记（stop the world）
    * 标记GC Roots能直接关联到的对象，速度快
  * 并发标记
    * GC Roots Trace过程
  * 重新标记（stop the world）
    * 标记并发标记阶段，因用户线程运行导致标记产生变动的那一部分对象，一般比初始标记时间长
    
  * 并发清除
    * 并发清除已经标记的对象
* 优点
  * 总体来说，CMS内存回收过程与用户线程并发执行
  * 低停顿
* 缺点
  * 对CPU资源非常敏感
    * 与用户线程争夺CPU资源，导致用户线程运行效率下降，吞吐率变低。GC资源 = （CPU总数+3）/4
    * CPU数量少的时候采用增量式垃圾收集，效果不明显，已经废弃
    
  * CMS无法处理浮动垃圾
    * 并发清理阶段，用户线程还在运行，需要预留足够的空间给用户线程使用
    * JDk1.5中，当老年待使用了68%后，就会被激活
    * JDK1.6中，CMS的启动阈值提升到了92%
    * CMS运行失败旧货启动后备方案，使用Serial Old垃圾收集器
  * 收集结束时会产生大量的空间碎片
    * 在大对象无法找到连续的空间的时候，会触发Full GC
    * 可以设置在Full GC的时候进行内存整理，可以设定Full GC中整理空间的频率
    
#### G1收集器（Garbage First）  
* 特点
  * 面向服务器端的垃圾收集工具
  * 与其他垃圾收集器相比具备以下的优点
     * 并行与并发
       * 充分利用CPU、多核环境的优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器需要停顿工作线程来进行垃圾收集的操作，G1收集器可以通过并发让JAVA程序继续执行。
     * 分代收集
       * 与其他收集器一样，G1保留了分代收集的思想。可以采用不同的方式去处理新创建的对象和已经存活了多次的对象和熬过了多次GC的对象。这样可以获得更好的收集效果。
     * 空间整合
       * 采用标记整理的算法，从局部两个Region之间可以看做是复制算法。运作期间不会产生内存碎片。分配大对象不会因为碎片导致的空间不足而触发一次GC。
     * 可预测的停顿
       * G1除了降低停顿时间外，还建立可预测的停顿时间模型，，能让使用者明确在一个长度为M的时间内，消耗在垃圾收集上的时间不超过N秒。
       * 实现的方式是避免在JAVA堆上实现全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收获得空间、回收需要时间），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值大的区域。
   * 将Java堆划分为大小相等的独立区域，新生代和老年代是一部分Region的集合
* 步骤
  * 初始标记
  * 并发标记0
  * 最终标记
  * 筛选回收

### 内存分配与回收策略

#### 对象优先在Eden上分配

#### 大对象直接进入老年代

#### 长期存活的对象将进入老年代

#### 动态年龄判定

#### 空间分配担保