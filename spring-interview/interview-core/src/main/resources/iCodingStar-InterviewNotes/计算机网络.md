## 计算机网路

### Http与TCP的关系
* HTTP是应用层协议，TCP是传输层协议，IP是网络层协议
* IP主要解决网络路由和寻址问题
* TCP主要解决在IP层协议之上，如何可靠的传输数据，即接收端接收的数据包的大小和顺序和发送端保持一致，TCP协议是可靠的，面向连接的。

### HTTP协议是没有状态的
* HTTP对事务处理没有记忆功能，客户端向服务器发送完数据后，服务端不知道客户端什么状态。

### 长连接与短连接
#### 两种方案对比
[HTTP长连接和短连接 + Websocket](http://blog.csdn.net/duola8789/article/details/73623059)
* HTTP的长连接与短连接本质上是TCP的长连接短连接
* 短连接建立流程： 建立连接---数据传输---关闭连接 ....建立连接---数据传输---关闭连接
* 长连接建立流程： 建立连接---数据传输----数据传输---关闭连接
* 长连接的优点：省去较多建立与关闭的操作，减少浪费，节约时间。
* 长连接的缺点：连接数过多，会给服务器造成较大的压力
* 短连接的优点：服务器管理简单、存在的连接都是可用连接、不需要额外的控制手段
* 短连接的缺点：如果客户操作频繁，将在连接的建立与销毁上消耗大量的时间

#### HTTP1.0
* 默认使用短连接，为每一次资源请求建立一次会话

#### HTTP1.1
* 默认使用长连接，在HTTP请求头默认加入 `Conection:keep-alive`，在响应头中有控制长连接时间 `Keep-Alive:timeout=20`
* Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。
* TCP保活，在服务器段检测半关闭的连接

#### HTTP2.0

#### 长连接实现方法
* 在应用层使用heartbeat主动检测
* 改变socket的keep-alive选项，使其检测连接中断的时间间隔更小，满足实时性需求
  * 设置SO_KEEPALIVE
  * 设置SOCKET的TCP层（SOL_TCP）选项TCP_KEEPIDLE、TCP_KEEPINTVL和TCP_KEEPCNT
  ```
  TCP_KEEPIDLE：开始首次KeepAlive探测前的TCP空闭时间
  
  The tcp_keepidle parameter specifies the interval of inactivity that causes TCP to generate a KEEPALIVE transmission for an application that requests them. tcp_keepidle defaults to 14400 (two hours).
  
  TCP_KEEPINTVL：两次KeepAlive探测间的时间间隔
  
  The tcp_keepintvl parameter specifies the interval between the nine retries that are attempted if a KEEPALIVE transmission is not acknowledged. tcp_keepintvl defaults to 150 (75 seconds).
  
  TCP_KEEPCNT：断开前的KeepAlive探测次数
  
  The TCP_KEEPCNT option specifies the maximum number of keepalive probes to be sent. The value of TCP_KEEPCNT is an integer value between 1 and n, where n is the value of the systemwide tcp_keepcnt parameter. 
  
  如果心搏函数要维护客户端的存活，即服务器必须每隔一段时间必须向客户段发送一定的数据，那么使用SO_KEEPALIVE是有很大的不足的。因为SO_KEEPALIVE选项指"此套接口的任一方向都没有数据交换"。在Linux 2.6系列上，上面话的理解是只要打开SO_KEEPALIVE选项的套接口端检测到数据发送或者数据接受就认为是数据交换。因此在这种情况下使用 SO_KEEPALIVE选项 检测对方是否非正常连接是完全没有作用的，在每隔一段时间发包的情况， keep-alive的包是不可能被发送的。上层程序在非正常断开的情况下是可以正常发送包到缓冲区的。非正常端开的情况是指服务器没有收到"FIN" 或者 "RST"包。
  ```
  